{
  "title": "Activity启动模式-LaunchMode和Intent Flags",
  "cells": [
    {
      "type": "markdown",
      "data": "# Activity启动模式-LaunchMode和Intent Flags\n\n## 启动模式\n---\n\n### Standard\n**`标准模式`**,每当有一次Intent请求，就会创建一个新的Activity实例。\n#####  1.Android 5.0 之前\n* 同一应用内\n\t新生成的Activity，放入发送Intent者Task的栈顶。\n```\nTask #1 MainActivity(A应用)\nTask #1 StandardActivity(A应用)\nTask #1 StandardActivity(A应用)\n```\n* 跨应用启动\n\t 新生成的Activity，放入发送Intent者Task的栈的栈顶（尽管他们属于不同的程序，还是会放入调用者程序的栈内）。\n```\nTask #2 GalleryActivity(B应用)\nTask #2 StandardActivity(A应用)\n```\n这时，我们打开任务管理器（最近任务按钮）。会发现最近任务中现实的应用名为B应用，展示的界面却是A应用的StandardActivity(因为其位于Task栈顶)。\n\t \n#####\t2.Android 5.0 之后\n*  同一应用内\n\t 与Android 5.0之前保持一致\n*  跨应用启动\n\t会生成一个新的Task，新生成的Activity会放入刚创建的Task中，而不是5.0之前的发送者的Task。\n``` \nTask #2 GalleryActivity(B应用)\nTask #3 StandardActivity(A应用)\n```\n加入之前已存在A应用，我们又从B中启动了属于A应用的StandardActivity，则对应的任务管理器效果如下。 \n```\nTask #1 StandardActivity(A应用) \nTask #2 GalleryActivity(B应用)\nTask #3 StandardActivity(A应用)\n```\n##### 3.使用场景\nstandard这种启动模式适合于撰写邮件Activity或者社交网络消息发布Activity。如果你想为每一个intent创建一个Activity处理，那么就是用standard这种模式。\n\n### SingleTop\n\n**`栈顶复用模式`**. SingleTop其实和Standard几乎一样，使用SingleTop的Activity也可以创建很多个实例。唯一不同的就是，如果调用的目标Activity已经位于调用者的Task的栈顶，则不创建新实例，而是使用当前的这个Activity实例，并调用这个实例的onNewIntent方法。 \n在singleTop这种模式下，我们需要处理应用这个模式的Activity的onCreate和onNewIntent两个方法，确保逻辑正常。\n\n### SingleTask\n**`栈内复用模式`**.使用singleTask启动模式的Activity在一个应用Task中只会存在一个实例。如果这个实例已经存在，intent就会通过onNewIntent传递到这个Activity，即多次调用不会创建新实例。否则新的Activity实例被创建。\n情况包含以下几种：\n##### 1.同一程序内：\n1. 任务栈不存在, 初次启动SingleTask实例, 会创建任务栈和实例.\n\tGoogle在singleTask的[文档](http://developer.android.com/guide/components/tasks-and-back-stack.html)有这样一段描述：\n >The system creates a new task and instantiates the activity at the root of the new task.\n \n\t意思为 系统会创建一个新的Task，并创建Activity实例放入这个新的Task的底部。然而实际并非如此，在我的例子中，singleTask Activity并创建并放入了调用者所在的Task，而不是放入新的Task。\n\t怎样才能符合文档中所描述的情况呢？那就是 `taskAffinity`属性和singleTask启动模式配合使用.\n\t```xml\n\t<activity\n\t    android:name=\".SingleTaskActivity\"\n\t    android:label=\"singleTask launchMode\"\n\t    android:launchMode=\"singleTask\"\n\t    android:taskAffinity=\"com.zlq.stack\">\n\t</activity>\n\t\n\t```\n\t使用 `taskAffinity`属性会添加新的Activity栈，与SingleTask配合使用, Standard模式无效.新任务栈是com.zlq.stack.\n2. 任务栈存在, 初次启动SingleTask实例, Task栈中不存在singleTask Activity的实例。那么就需要创建这个Activity的实例，并且将这个实例放入和调用者相同的Task中并位于栈顶。与Standard模式相同.\n3.  任务栈相同,如果singleTask Activity实例已然存在,再次启动SingleTask实例, 那么在Activity回退栈中，所有位于该Activity上面的Activity实例都将被销毁掉（销毁过程会调用Activity生命周期回调），这样使得singleTask Activity实例位于栈顶（具有clearTop的效果）。与此同时，Intent会通过onNewIntent传递到这个SingleTask Activity实例。 并清除其上面实例, 具有clearTop的效果.最终，singleTask Activity实例会位于栈顶。\n4.  任务栈不同, 再次启动SingleTask实例, 会导致任务栈切换, 后台置于前台.\n\n##### 2.跨应用之间：\n\n#####  3.使用场景：\n该模式的使用场景多类似于邮件客户端的收件箱或者社交应用的时间线Activity。上述两种场景需要对应的Activity只保持一个实例即可，但是也要谨慎使用这种模式，因为它可以在用户未感知的情况下销毁掉其他Activity。\n\n\n### SingleInstance\n**`单实例模式`**启动时, 系统会为其创造一个单独的任务栈, 以后每次使用, 都会使用这个单例, 直到其被销毁, 属于真正的单例模式.singleTask差不多，唯一不同的就是存放singleInstance Activity实例的Task只能存放一个该模式的Activity实例，不能有任何其他的Activity。\n虽然是两个task，但是在系统的任务管理器中，却始终显示一个，即位于顶部的Task中。\n\n### `startActivityForResult:`\nstartActivityForResult不同于startActivity, 使用LaunchMode模式启动Activity时, 也会有一些不同, 可以正常传递数据, 但是无法连续创建自己时, 会生成多份实例.\n\nTestB(singleTask模式)使用startActivity创建自己时, 会使用默认实例, 即单例; 而使用startActivityForResult创建自己时, 会生成一份新的示例.\n\n``` \nStack #1:\n  Running activities (most recent first):\n    TaskRecord{323200ac #2786 A=me.chunyu.clwang.stack U=0 sz=3}\n      Run #4: ActivityRecord{3f9e14f3 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2786}\n      Run #3: ActivityRecord{30d8f17b u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2786}\n      Run #2: ActivityRecord{11b95b5c u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestBActivity t2786}\n    TaskRecord{c86e175 #2785 A=me.chunyu.spike.wcl_activity_launchmode_demo U=0 sz=2}\n      Run #1: ActivityRecord{3558d7c4 u0 me.chunyu.spike.wcl_activity_launchmode_demo/.TestAActivity t2785}\n      Run #0: ActivityRecord{1b8620c u0 me.chunyu.spike.wcl_activity_launchmode_demo/.MainActivity t2785}\n\n```\n\n由此可知, 因为startActivityForResult需要返回值, 会保留实例, 覆盖单例效果.\n\n>注意: 4.x版本通过startActivityForResult启动singleTask, 无法正常获取返回值, [参考](http://stackoverflow.com/questions/8960072/onactivityresult-with-launchmode-singletask).\n5.x以上版本修复此问题, 考虑兼容性, 不推荐使用startActivityForResult和singleTask.\n\n\n## Intent Flags\n\n\n## 总结\n\n\n\n"
    }
  ]
}