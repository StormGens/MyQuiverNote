{
  "title": "Android消息机制（三）：Looper",
  "cells": [
    {
      "type": "markdown",
      "data": "Looper在Android消息机制中的主要作用就是一直循环从MessageQueue中取Message，取出Message后交给它的target，该target是一个Handler对象，消息交给Handler后通过调用Handler的`dispatchMessage()`方法进行处理。\n## 类成员\nfiled | 含义 |说明\n------------ | ------------- | -------\nsThreadLocal | Looper 对象|每个线程中的Looper对象其实是一个ThreadLocal，即线程本地存储(TLS)对象\nsMainLooper |主线程使用的Looper对象 |由系统在ActivityThread主线程中创建。\nmQueue | 和Looper对应的消息队列 | 一个Looper依赖一个消息队列（一对一）\nmThread | 和Looper对应的线程 | 一个Looper和一个线程绑定（一对一）\n## Looper工作过程\n1. **为线程创建消息循环**\n 使用Looper对象时，会先调用静态的prepare方法或者prepareMainLooper方法来创建线程的Looper对象。如果是主线程会调用prepareMainLooper，如果是普通线程只需调用prepare方法，两者都会调用prepare(boolean quitAllowed)方法，该方法源码如下：\n```java\n    /**\n     * 该方法会创建Looper对象，Looper对象的构造方法中会创建一个MessageQueue对象，再将Looper对象保存到当前线程 TLS\n     * @param quitAllowed\n     */\n    private static void prepare(boolean quitAllowed) {\n        if (sThreadLocal.get() != null) {\n            // 试图在有Looper的线程中再次创建Looper将抛出异常，一个线程只能有一个looper。\n            throw new RuntimeException(\"Only one Looper may be created per thread\");\n        }\n        // 我们调用该方法会在调用线程的TLS中创建Looper对象\n        sThreadLocal.set(new Looper(quitAllowed));\n    }\n```\n> 第一次调用prepare()方法后，新创建出来的当前线程对应的Looper对象就被存储到一个`TLS`对象中，如果重复调用，就会报错。\n\n2. **开启消息循环**\nLooper类乃至Android消息处理机制的核心部分，在使用Looper时，调用完`Looper.prepare()`后，还需要调用Looper.loop()方法开启消息循环。该方法是一个死循环会将不断重复下面的操作，直到没有消息时退出循环。\n\n  1. 读取MessageQueue的下一条Message\n  2. 把Message分发给相应的target（Handler）来处理\n  3. 把分发后的Message，回收到消息池以复用\n```java\n  /**\n     * 在这个线程中启动队列，请确保在循环结束时候调用{@link #quit()}\n     *\n     * Run the message queue in this thread. Be sure to call\n     * {@link #quit()} to end the loop.\n     */\n    public static void loop() {\n        final Looper me = myLooper();//获取TLS存储的Looper对象\n        if (me == null) {//如果没有调用Loop.prepare()的话，就会抛出下面这个异常\n            throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\");\n        }\n        final MessageQueue queue = me.mQueue;//从Looper中取出消息队列\n\n        // Make sure the identity of this thread is that of the local process,\n        // and keep track of what that identity token actually is.\n        Binder.clearCallingIdentity();\n        //确保在权限检查时基于本地进程，而不是基于最初调用进程。\n        final long ident = Binder.clearCallingIdentity();\n\n        //死循环，循环的取消息，没有新消息就会阻塞\n        for (;;) {\n            //调用MessageQueue的next方法来获取新消息，而，next是一个阻塞方法，没有消息时，loop方法将跟随next方法会一直阻塞在这里。\n            Message msg = queue.next(); // might block,如果没有新消息,这里会被阻塞。\n            //因为以上获取消息是阻塞方法，所以，当消息队列中没有消息时，将阻塞在上一步。而如果上一步拿到了一个空消息，只能说明\n            //我们退出了该消息队列。那么这里直接退出\n            if (msg == null) {\n                // No message indicates that the message queue is quitting.\n                //没有消息意味着消息队列正在退出。这也就是为什么Looper的quit(）方法中只需要退出消息队列即可。\n                return;\n            }\n\n            // This must be in a local variable, in case a UI event sets the logger\n            Printer logging = me.mLogging;//默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能\n            if (logging != null) {\n                logging.println(\">>>>> Dispatching to \" + msg.target + \" \" +\n                        msg.callback + \": \" + msg.what);\n            }\n\n            msg.target.dispatchMessage(msg); //msg.target就是与此线程关联的Handler对象，调用它的dispatchMessage处理消息\n\n            if (logging != null) {\n                logging.println(\"<<<<< Finished to \" + msg.target + \" \" + msg.callback);\n            }\n\n            // Make sure that during the course of dispatching the\n            // identity of the thread wasn't corrupted.\n            final long newIdent = Binder.clearCallingIdentity();//确保分发过程中identity不会损坏\n            if (ident != newIdent) {\n                Log.wtf(TAG, \"Thread identity changed from 0x\"\n                        + Long.toHexString(ident) + \" to 0x\"\n                        + Long.toHexString(newIdent) + \" while dispatching to \"\n                        + msg.target.getClass().getName() + \" \"\n                        + msg.callback + \" what=\" + msg.what);\n            }\n\n            msg.recycleUnchecked(); //将已经处理过的消息会受到消息池\n        }\n    }\n```\n> 上面代码中可以看到有logging方法，这是用于debug的，默认情况下logging == null，通过设置setMessageLogging()用来开启debug工作。\n\n3. **获得消息循环**\n `myLooper()`方法用于获取当前消息循环对象。Looper对象从成员变量 sThreadLocal(`线程本地存储(TLS)对象`) 中获取。\n> 获得的Looper对象可以作为Handler的构建函数参数，将在下篇文章中说明。\n* **退出消息循环**\n主要是退出消息队列:\n```java\n    public void quit() {\n        mQueue.quit(false);//消息移除\n    }\n    public void quitSafely() {\n        mQueue.quit(true);\n    }\n```\n\n## 一些其他方法\n* **Looper构造方法**\nLooper在执行静态方法`Looper.loop()`时调用Looper的构造函数（代码见上文）。在Looper初始化时，新建了一个MessageQueue的对象保存了在成员mQueue中。Looper是依赖于一个线程和一个消息队列的。\n```java\n    private Looper(boolean quitAllowed) {\n        // 每个Looper对象中有它的消息队列，和它所属的线程\n        mQueue = new MessageQueue(quitAllowed);\n        mThread = Thread.currentThread();\n    }\n```\n* **prepareMainLooper()**\n该方法只在主线程中调用，系统已帮我们做好，我们一般不用也不能调用。\n"
    }
  ]
}