{
  "title": "Android消息机制（二）：Message和MessageQueue",
  "cells": [
    {
      "type": "markdown",
      "data": "## Message\n### 消息结构\n每个消息用Message表示，Message主要包含以下内容：\n\nfiled | 含义 |说明\n------------ | ------------- | --------\nwhat | 消息类别|由用户定义，用来区分不同的消息\narg1 | 参数1|是一种轻量级的传递数据的方式\narg2 | 参数2|是一种轻量级的传递数据的方式\nobj | 消息内容|任意对象，但是使用Messenger跨进程传递Message时不能为null\ndata |Bundle数据|比较复杂的数据建议使用该变量（相比上面几个，这个县的比较重量级）\ntarget | 消息响应方|关联的Handler对象，处理Message时会调用它分发处理Message对象\nwhen | 触发响应时间|处理消息时间\n`next`|Message队列里的下一个Message对象|用next指向下一条Message，实现一个链表数据结构，用户一般使用不到该字段。\n\n> 这里的用户指一般的APP开发者。\n\n一般不用手动设置target,调用Handler.obtainMessage()方法会自动的设置Message的target为当前的Handler。\n得到Message之后可以调用sendToTarget(),发送消息给Handler，Handler再把消息放到message queue的尾部。\n对Message除了给部分成员变量赋值外的操作都可以交由Handler来处理。\n\n### 消息池\n在通过Handler发送消息时，我们可以通过代码`Message message=new Message();`新建一条消息，但是我们并不推荐这样做，因为这样每次都会新建一条消息，很容易造成资源浪费。Android中设计了消息池用于避免该现象：\n* 获取消息 `obtain()`\n从消息池中获取消息: `Message msg=Message.obtain();`\nobtain()方法源码：\n```java\n  public static Message obtain() {\n        synchronized (sPoolSync) {\n            if (sPool != null) {\n                Message m = sPool;\n                sPool = m.next;\n                m.next = null; //从sPool中取出一个Message对象，并消息链表断开\n                m.flags = 0; // clear in-use flag清除in-use flag\n                sPoolSize--;//消息池的可用大小进行-1操作\n                return m;\n            }\n        }\n        return new Message();// 当消息池为空时，直接创建Message对象\n    }\n```\n> 从消息池取Message，都是把消息池表头的Message取走，再把表头指向下一条消息`next`;\n\n* 回收消息 `recycle()`\n把不再使用的消息回收到消息池 `mgs.recycle();`\nrecycle()方法源码:\n```java\npublic void recycle() {\n        if (isInUse()) {//判断消息是否正在使用\n            if (gCheckRecycle) {\n                throw new IllegalStateException(\"This message cannot be recycled because it \"\n                        + \"is still in use.\");\n            }\n            return;\n        }\n        recycleUnchecked();\n    }\n\n    /**\n     * 对于不再使用的消息，加入到消息池\n     * Recycles a Message that may be in-use.\n     * Used internally by the MessageQueue and Looper when disposing of queued Messages.\n     */\n    void recycleUnchecked() {\n        // Mark the message as in use while it remains in the recycled object pool.\n        // Clear out all other details.\n        //将消息标示位置为IN_USE，并清空消息所有的参数。\n        flags = FLAG_IN_USE;\n        what = 0;\n        arg1 = 0;\n        arg2 = 0;\n        obj = null;\n        replyTo = null;\n        sendingUid = -1;\n        when = 0;\n        target = null;\n        callback = null;\n        data = null;\n\n        synchronized (sPoolSync) {\n            if (sPoolSize < MAX_POOL_SIZE) {//当消息池没有满时，将Message对象加入消息池\n                next = sPool;\n                sPool = this;\n                sPoolSize++;//消息池的可用大小进行加1操作\n            }\n        }\n    }\n```\n> 消息回收，就是将Message内容重置后，再把Message加到链表的表头，加入到消息池的过程；\n\n## MessageQueue\n负责管理消息队列，实际上Message类有一个next字段，会将Message对象串在一起成为一个消息队列，所以并不需要LinkedList之类的数据结构将Message对象组在一起成为队列。\n* **创建消息队列**\n ```java\n     MessageQueue(boolean quitAllowed) {\n        mQuitAllowed = quitAllowed;\n        mPtr = nativeInit();//通过native方法初始化消息队列，其中mPtr是供native代码使用\n    }\n ```\n 在MessageQueue初始化的时候调用了nativeInit，这是一个Native方法：\n ```C++\n static void android_os_MessageQueue_nativeInit(JNIEnv* env, jobject obj) { \n    NativeMessageQueue* nativeMessageQueue = new NativeMessageQueue(); \n    if (!nativeMessageQueue) { \n        jniThrowRuntimeException(env, \"Unable to allocate native queue\"); \n        return;\n        }\n    nativeMessageQueue->incStrong(env); \n    android_os_MessageQueue_setNativeMessageQueue(env, obj, nativeMessageQueue);\n } \n static void android_os_MessageQueue_setNativeMessageQueue(JNIEnv* env, jobject messageQueueObj,\n        NativeMessageQueue* nativeMessageQueue) { \n    env->SetIntField(messageQueueObj, gMessageQueueClassInfo.mPtr, \n    reinterpret_cast<jint>(nativeMessageQueue)); \n  }\n ```\n 方法名由java层类的包名+类名+方法名组成，这不是标准，是习惯写法，也可以采用其他名称组合，具体是什么名称由JNINativeMethod方法中Java对象与c++对象的映射决定，此处是JNI方面的内容，不作过多解释。\n 在nativeInit中，new了一个Native层的MessageQueue的对象，并将其地址保存在了Java层MessageQueue的成员mPtr中，Android中有好多这样的实现，一个类在Java层与Native层都有实现，通过JNI的GetFieldID与SetIntField把Native层的类的实例地址保存到Java层类的实例的mPtr成员中，比如Parcel。\n\n再看NativeMessageQueue的实现：\n\n```C++\nNativeMessageQueue::NativeMessageQueue() : mInCallback(false), mExceptionObj(NULL) { \n    mLooper = Looper::getForThread();\n    if (mLooper == NULL) {\n      mLooper = new Looper(false);\n      Looper::setForThread(mLooper); \n    }\n}\n```\n \n* **消息入队 `enqueueMessage()`**\nenqueueMessage 用于将Message对象插入消息队列。MessageQueue永远是按照Message触发的时间先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。\n该方法会被Handler对象调用。\n源码如下：\n```java\n   /**\n     * 添加一条消息到消息队列\n     * @param msg 要添加的消息\n     * @param when 消息处理时间\n     * @return 添加成功与否\n     */\n    boolean enqueueMessage(Message msg, long when) {\n        if (msg.target == null) {// 每一个Message必须有一个target\n            throw new IllegalArgumentException(\"Message must have a target.\");\n        }\n        if (msg.isInUse()) {\n            throw new IllegalStateException(msg + \" This message is already in use.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) {\n                IllegalStateException e = new IllegalStateException(\n                        msg.target + \" sending message to a Handler on a dead thread\");\n                Log.w(TAG, e.getMessage(), e);\n                msg.recycle();\n                return false;\n            }\n\n            msg.markInUse();\n            msg.when = when;\n            Message p = mMessages;\n            boolean needWake;\n            if (p == null || when == 0 || when < p.when) {\n                // New head, wake up the event queue if blocked.\n                //p为null(代表MessageQueue没有消息） 或者msg的触发时间是队列中最早的， 则进入该该分支\n                msg.next = p;\n                mMessages = msg;\n                needWake = mBlocked;\n            } else {\n                //将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非\n                //消息队头存在barrier，并且同时Message是队列中最早的异步消息。\n\n                // Inserted within the middle of the queue.  Usually we don't have to wake\n                // up the event queue unless there is a barrier at the head of the queue\n                // and the message is the earliest asynchronous message in the queue.\n                needWake = mBlocked && p.target == null && msg.isAsynchronous();\n                Message prev;\n                for (;;) {\n                    prev = p;\n                    p = p.next;\n                    if (p == null || when < p.when) {\n                        break;\n                    }\n                    if (needWake && p.isAsynchronous()) {\n                        needWake = false;\n                    }\n                }\n                msg.next = p; // invariant: p == prev.next\n                prev.next = msg;\n            }\n\n            // We can assume mPtr != 0 because mQuitting is false.\n            //消息没有退出，我们认为此时mPtr != 0\n            if (needWake) {\n                nativeWake(mPtr);\n            }\n        }\n        return true;\n    }\n```\n* **消息轮询 `next()`**\n最重要的方法,用于获取下一个Message对象，如果没有需要处理的Message对象，该方法将阻塞。MessageQueue用本地方法做同步互斥，因为这样时间更精准。每个Message对象都有一个什么时刻处理该Message对象的属性when，没到时间都不会处理该Message对象，如果时间不精准的话，会导致系统消息不能及时处理。 \n```java\n   /**\n     * 依次从MessageQueue中取出Message\n     * @return 消息\n     */\n    Message next() {\n        // Return here if the message loop has already quit and been disposed.\n        // This can happen if the application tries to restart a looper after quit\n        // which is not supported.\n        final long ptr = mPtr;\n        if (ptr == 0) {//当消息循环已经退出，则直接返回\n            return null;\n        }\n\n        int pendingIdleHandlerCount = -1; // -1 only during first iteration  循环迭代的首次为-1\n        int nextPollTimeoutMillis = 0;\n        for (;;) {\n            if (nextPollTimeoutMillis != 0) {\n                Binder.flushPendingCommands();\n            }\n            //阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回。\n            nativePollOnce(ptr, nextPollTimeoutMillis);\n\n            synchronized (this) {\n                // Try to retrieve the next message.  Return if found.\n                final long now = SystemClock.uptimeMillis();\n                Message prevMsg = null;\n                Message msg = mMessages;\n                if (msg != null && msg.target == null) {\n                    //查询MessageQueue中的下一条异步消息\n                    // Stalled by a barrier.  Find the next asynchronous message in the queue.\n                    do {\n                        prevMsg = msg;\n                        msg = msg.next;\n                    } while (msg != null && !msg.isAsynchronous());\n                }\n                if (msg != null) {\n                    if (now < msg.when) {\n                        //设置下一次轮询消息的超时时间\n                        // Next message is not ready.  Set a timeout to wake up when it is ready.\n                        nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE);\n                    } else {\n                        // 获取一条消息，并返回\n                        // Got a message.\n                        mBlocked = false;\n                        if (prevMsg != null) {\n                            prevMsg.next = msg.next;\n                        } else {\n                            mMessages = msg.next;\n                        }\n                        msg.next = null;\n                        if (DEBUG) Log.v(TAG, \"Returning message: \" + msg);\n                        msg.markInUse();//设置消息flag成使用状态\n                        return msg;//成功地获取MessageQueue中的下一条即将要执行的消息\n                    }\n                } else {\n                    // No more messages.//没有消息了\n                    nextPollTimeoutMillis = -1;\n                }\n\n                // Process the quit message now that all pending messages have been handled.\n                if (mQuitting) {//消息正在退出，返回null\n                    dispose();\n                    return null;\n                }\n\n                // If first time idle, then get the number of idlers to run.\n                // Idle handles only run if the queue is empty or if the first message\n                // in the queue (possibly a barrier) is due to be handled in the future.\n                //当消息队列为空，或者消息队列的第一个消息时\n                if (pendingIdleHandlerCount < 0\n                        && (mMessages == null || now < mMessages.when)) {\n                    pendingIdleHandlerCount = mIdleHandlers.size();\n                }\n                if (pendingIdleHandlerCount <= 0) {\n                    //没有idle handlers 需要运行，则循环并等待。\n                    // No idle handlers to run.  Loop and wait some more.\n                    mBlocked = true;\n                    continue;\n                }\n\n                if (mPendingIdleHandlers == null) {\n                    mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)];\n                }\n                mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers);\n            }\n\n            // Run the idle handlers.\n            // We only ever reach this code block during the first iteration.\n            //只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0.\n            for (int i = 0; i < pendingIdleHandlerCount; i++) {\n                final IdleHandler idler = mPendingIdleHandlers[i];\n                mPendingIdleHandlers[i] = null; // release the reference to the handler//去掉handler的引用\n\n                boolean keep = false;\n                try {\n                    keep = idler.queueIdle();//idle时执行的方法\n                } catch (Throwable t) {\n                    Log.wtf(TAG, \"IdleHandler threw exception\", t);\n                }\n\n                if (!keep) {\n                    synchronized (this) {\n                        mIdleHandlers.remove(idler);\n                    }\n                }\n            }\n\n            // Reset the idle handler count to 0 so we do not run them again.\n            //重置idle handler个数为0，以保证不会再次重复运行\n            pendingIdleHandlerCount = 0;\n\n            // While calling an idle handler, a new message could have been delivered\n            // so go back and look again for a pending message without waiting.\n            //当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message.\n            nextPollTimeoutMillis = 0;\n        }\n    }\n```\n> nativePollOnce(ptr, nextPollTimeoutMillis)是一个native方法，是一个阻塞操作。其中nextPollTimeoutMillis代表下一个消息到来前，还需要等待的时长；当nextPollTimeoutMillis = -1时，表示消息队列中无消息，会一直等待下去。空闲后，往往会执行IdleHandler中的方法。当nativePollOnce()返回后，next()从mMessages中提取一个消息。nativePollOnce()在native做了大量的工作，想深入研究可查看资料： [Android消息机制2-Handler(Native层)](http://gityuan.com/2015/12/27/handler-message-native/)。\n\n* **移除消息 `removeMessages()`**\n就是将消息从链表移除，同时将移除的消息添加到消息池，提供循环复用。\n采用了两个while循环，第一个循环是从队头开始，移除符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。\n```java\n    void removeMessages(Handler h, int what, Object object) {\n        if (h == null) {\n            return;\n        }\n\n        synchronized (this) {\n            Message p = mMessages;\n            //从消息队列的头部开始，移除所有符合条件的消息\n            // Remove all messages at front.\n            while (p != null && p.target == h && p.what == what\n                   && (object == null || p.obj == object)) {\n                Message n = p.next;\n                mMessages = n;\n                p.recycleUnchecked();\n                p = n;\n            }\n\n            // Remove all messages after front.\n            //移除剩余的符合要求的消息\n            while (p != null) {\n                Message n = p.next;\n                if (n != null) {\n                    if (n.target == h && n.what == what\n                        && (object == null || n.obj == object)) {\n                        Message nn = n.next;\n                        n.recycleUnchecked();\n                        p.next = nn;\n                        continue;\n                    }\n                }\n                p = n;\n            }\n        }\n    }\n```\n* 退出消息队列\n消息退出的方式：\n  - 当safe =true时，只移除尚未触发的所有消息，对于正在触发的消息并不移除；\n  - 当safe =flase时，移除所有的消息\n  \n  ```java\n void quit(boolean safe) {\n        if (!mQuitAllowed) {// 当mQuitAllowed为false，表示不运行退出，强行调用quit()会抛出异常\n            throw new IllegalStateException(\"Main thread not allowed to quit.\");\n        }\n\n        synchronized (this) {\n            if (mQuitting) { //防止多次执行退出操作\n                return;\n            }\n            mQuitting = true;\n\n            if (safe) {\n                removeAllFutureMessagesLocked();//移除尚未触发的所有消息\n            } else {\n                removeAllMessagesLocked();//移除所有的消息\n            }\n\n            // We can assume mPtr != 0 because mQuitting was previously false.\n            //mQuitting=false，那么认定为 mPtr != 0\n            nativeWake(mPtr);\n        }\n    }\n```"
    }
  ]
}